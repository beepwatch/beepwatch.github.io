{"meta":{"title":"怀表の后花园","subtitle":null,"description":"生活不易，丛雨叹气(๑´ㅂ`๑)","author":"嘟嘟噜の怀表","url":"https://beepwatch.github.io","root":"/"},"pages":[{"title":"404","text":"页面被吃掉了www","path":"404/index.html","date":"03-09","excerpt":""},{"title":"categories","text":"","path":"categories/index.html","date":"03-10","excerpt":""},{"title":"关于嘟嘟噜の怀表(｀・ω・´)","text":"超级柚子厨，最喜欢幼刀（划掉）C，C艹，html，python绝赞学习ing QAQB站：嘟嘟噜の怀表路过的话请给视频点个赞哦 嘤嘤嘤~","path":"about/index.html","date":"03-09","excerpt":""},{"title":"message","text":"","path":"message/index.html","date":"03-10","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"03-09","excerpt":""},{"title":"tags","text":"","path":"tags/index.html","date":"03-10","excerpt":""}],"posts":[{"title":"Hello World","text":"我也不知道为什么要留着这个=v= Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2021/06/16/hello-world/","date":"06-16","excerpt":"我也不知道为什么要留着这个=v=","tags":[],"preview":"/imgs/preview/preview2.jpg"},{"title":"C++的一些输出格式控制函数","text":"见如下代码： #include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; int main()&#123; double a=123.456789012345; //cin&gt;&gt;a; cout&lt;&lt;a&lt;&lt;endl;//结果是123.456,以十进制小数格式输出，默认6位有效数字(当a现在的有效数字大于6时，否则输出实际有效位数) cout&lt;&lt;setprecision(9)&lt;&lt;a&lt;&lt;endl;//结果是123.456789，同上，修改有效数字为9位 cout&lt;&lt;setprecision(6); cout&lt;&lt;a&lt;&lt;endl;//结果还是123.456,以十进制小数格式输出，但是保留6位有效数字 cout&lt;&lt;setiosflags(ios::fixed); cout&lt;&lt;a&lt;&lt;endl;//结果是123.456789，因为setiosflags(ios::fixed)使setprecision(n)中n的含义由有效数字变成了小数点后位数 cout&lt;&lt;setprecision(8); cout&lt;&lt;a&lt;&lt;endl;//结果是123.45678901，说明&lt;setiosflags(ios::fixed)的效果持续存在//打印数字会四舍五入//四舍五入可以利用整数截断，先对小数+0.5再符指3给一个整型变量 cout&lt;&lt;setfill(&#39;#&#39;)&lt;&lt;setw(10)&lt;&lt;&quot;QAQ&quot;&lt;&lt;endl;//结果是#######QAQ，setfill(&#39;#&#39;)是设置填充字符，不用此函数则默认用空格 cout&lt;&lt;setw(12)&lt;&lt;&quot;QWQ&quot;&lt;&lt;endl;//结果是#########QWQ，setw的效果只对其后一个输出项有效，而setfill的效果持续 cout&lt;&lt;setw(10)&lt;&lt;setfill(&#39;@&#39;)&lt;&lt;&quot;QAQ&quot;&lt;&lt;endl;//结果是@@@@@@@QAQ，setw和setfill不分先后，其他控制函数应该同理 cout&lt;&lt;setw(12)&lt;&lt;&quot;QWQ&quot;&lt;&lt;endl;//结果是@@@@@@@@@QWQ &#125;","path":"2021/06/10/C-的一些输出格式控制函数/","date":"06-10","excerpt":"","tags":[],"preview":null},{"title":"随机数的生成","text":"介绍两个函数rand( );和srand( );头文件：&lt;stdlib.h&gt;或&lt;cstdlib&gt;函数原型： int rand(void); void srand(unsigned seed); 函数说明：rand()函数产生的随机数严格意义讲不是真正的随机数，它里面采用了线性同余法计算出随机数，该方法有个最大周期M，也就是说该方法实在一定的范围内生成一串数字，不过这个M一般来说比较大，所以正常使用时一般看起来就是产生了随机的数，不过这个函数由于默认种子是1，所以每次产生的随机数都是相同的，也就是说每次运行程序，产生的随机数都是一样的，失去了部分随机的意义，所以一般会配合srand函数使用。 返回值: 返回0至RAND_MAX之间的随机整数值，RAND_MAX的值32767（16位系统） srand()函数为rand()函数提供随机数种子，常用系统时间做参数time(NULL)，需要time.h两函数应该配合使用，如果不调用srand()直接使用rand()，则默认srand(1); 要取得[a,b)的随机整数，使用(rand() % (b-a))+ a;要取得[a,b]的随机整数，使用(rand() % (b-a+1))+ a;要取得(a,b]的随机整数，使用(rand() % (b-a))+ a + 1;通用公式:a + rand() % n；其中的a是起始值，n是整数的范围。要取得a到b之间的随机整数，另一种表示：a + (int)b * rand() / (RAND_MAX + 1)。要取得0～1之间的浮点数，可以使用rand() / double(RAND_MAX)。 每次种子更新之后是什么？","path":"2021/06/10/随机数的生成/","date":"06-10","excerpt":"","tags":[],"preview":null},{"title":"C++的前置声明","text":"【1】一般的前置函数声明见过最多的前置函数声明，基本格式代码如下： #include using namespace std; void fun(char ch, int *pValue, double dValue); void main(){ int nValue = 100; double dValue = 111.22; fun(‘a’, &amp;nValue, dValue); system(“pause”);} void fun(char ch, int *pValue, double dValue){ return;} 很好理解，不做赘述。 【2】自定义类型的前置声明自定义类型的前置声明，由于编译器不知道类型的大小，所以不可以声明类型的对象。只可以利用类型声明指针和引用。 代码如下： /* 自定义类型前置声明 /#include using namespace std; class B; class A{private: // 内置类型 int m_nInt; int&amp; m_nRInt; int* m_pInt; // 自定义类型// B b; // error！ B* m_pB; B&amp; m_b; public: A (B *pBPara = NULL) : m_nInt(100) , m_nRInt(m_nInt) , m_pInt(NULL) , m_pB(NULL) , m_b((NULL == pBPara) ? (*m_pB) : (*pBPara)) { cout &lt;&lt; “A()” &lt;&lt; endl; } A() { cout &lt;&lt; “A()” &lt;&lt; endl; } void funA() {// m_pB-&gt;doAnything(); // build error C2027: use of undefined type ‘B’ }}; class B{private: int m_n; public: B (int n = 100) : m_n(n) { cout &lt;&lt; “B()” &lt;&lt; endl; } /B() { cout &lt;&lt; “B()” &lt;&lt; endl; } void doAnything() { cout &lt;&lt; “B::anythig()” &lt;&lt; endl; }}; void main(){ A objA; system(“pause”);} 如上，利用前置类型的指针想调用其成员函数，会报编译错误！那么，肿么办？请看下文。 【3】声明和实现分离代码如下，声明头文件： /* TestForwardDeclar.h /#ifndef D_TESTFORWARDDECLAR_H_#define D_TESTFORWARDDECLAR_H_ #include class B; // 前置声明自定义类型 class A{private: // 内置类型 int m_nInt; int&amp; m_nRInt; int* m_pInt; // 自定义类型// B b; // error！ B* m_pB; B&amp; m_b; public: A (B *pBPara = NULL); ~A (); void funA();}; class B{private: int m_n; public: B (int n = 100); ~B (); void doAnything();}; #endif 代码如下，定义文件： /* TestForwardDeclar.cpp / #include “TestForwardDeclar.h”#include A::A (B *pBPara) : m_nInt(100) , m_nRInt(m_nInt) , m_pInt(NULL) , m_pB(NULL) , m_b((NULL == pBPara) ? (*m_pB) : (*pBPara)){ std::cout &lt;&lt; “A()” &lt;&lt; std::endl;} A::A(){ std::cout &lt;&lt; “A()” &lt;&lt; std::endl;} void A::funA(){ m_pB-&gt;doAnything(); // 分开头文件和实现文件即可} B::B (int n) : m_n(n){ std::cout &lt;&lt; “B()” &lt;&lt; std::endl;} B::B(){ std::cout &lt;&lt; “B()” &lt;&lt; std::endl;} void B::doAnything(){ std::cout &lt;&lt; “B::anythig()” &lt;&lt; std::endl;} 代码如下：测试文件： #include “TestForwardDeclar.h” void main() { A objA;} 【4】总结自定义类型前置声明时，只可以利用类型名声明指针和引用变量（谨记不可以声明对象或new 对象，均因为类型大小不确定，编译器无能为力）。 若需要利用指针或引用调用前置类型的接口，必须按照声明和实现分离的方式进行编码。 转载自：https://www.jb51.net/article/115357.htm","path":"2021/06/02/C-的前置声明/","date":"06-02","excerpt":"","tags":[],"preview":null},{"title":"随便写一点C++相关内容","text":"C++之路道阻且长TAT 前言C++项目的组成：cpp文件，h/hpp文件，外部库文件（dll,lib,exe等），资源文件（rc,res)，数据文件（数据库、XML、dat等），其他利用make工具等编译生成可执行文件（exe,dll等）Windows的静态库文件扩展名是 .lib，动态库文件扩展名是 .dll (Dynamic-Link Libraries)相应的，有静态编译和动态编译 C++项目编译过程概述：mycpp.prj{file01.cpp,file02.cpp,…,xx.rc}–预编译过程–&gt;{file01.cpp’,file02.cpp’,…}–编译过程(compile)–&gt;{file01.obj,file02.obj,…,xx.res}–链接过程(link)–&gt;mycpp.exe .prj：工程文件，统领若干cpp文件和其他一些文件.rc：一些资源文件.cpp’：预编译后得到的副本文件.obj：目标文件cpp文件是独立编译的，是最小编译单元，一个cpp文件和其他cpp文件没有关系，只在最后的链接过程产生联系 1.预编译过程：预处理源代码中的带有#号的语句，生成编译程序可处理的文本文件，对某个cpp文件将头文件进行展开插入，并且放在内存中，提高编译速度2.编译过程：对每个预处理后源程序，编译并生成相应的的二进制目标文件（object文件）此过程中，要求编译器能够识别每个标识符，知道其各自的类型、含义，但不要求知道存放位置3.链接过程：用到一些库(.lib,.dll)，对在整个程序范围内，确定各标识符所代表的地址，如变量、函数入口，生成可执行文件此过程中，要求编译器能够确定每个标识符所对应的含义或地址这里的地址指变量或函数在文件中的具体位置 这三步统称编译过程，这里的错误称为语法错误，这里必须会自己掌握相应的，成功生成可执行文件后的错误是逻辑错误 make工具说明通过比对源文件和要生成的文件的时间戳，选择并决定编译哪些文件，提高编译速度 入口函数（main函数）返回值：int或void，缺省为int（C++17(C++1z)要求int） 命令行参数：int argc,char *argv[ ] 头文件扩展名：.h,.hpp,无扩展名.h是C中的，.hpp是C++中的（,h是最常用的），无扩展名通常是系统的头文件 标准库：系统预定义的文件，其可执行代码通常存在于操作系统，或者随编译器一同发布，属于标准C++的一部分&lt; &gt;：在系统目录中查找相应的头文件（system目录或者编译器提供的目录）“ “：先在本地（当前工程）的目录中查找相应的头文件；若找不到，再到系统目录中查找相应的头文件括号或引号里可以写成绝对路径或相对路径的形式 #include和#include&lt;xx.h&gt;前者是C++的风格大体上：#include相当于（是相当于，不是等价） namespace std&#123; #include&quot;xx.h&quot; &#125; 书写风格：一般是把尖括号（&lt; &gt;）放在前面（注意#include “stdafx.h”这个东西的存在），自己写的.h文件（” “）放在后面不然可能会造成报错信息产生在尖括号的include那一行，让你百思不得其解 前置声明：告诉编译器，一个标识符所代表的类型，含义等，但不必告知其具体位置 在C++中可以使用类的前置声明类似函数声明如定义了类class A class A&#123; ... &#125;; 想要在定义之前使用class A,就需要前置声明 class A; //对于结构体struct也可以使用class xxx来前置声明，结构体本身就是默认类型为public的类，但是不能使用struct xxx，struct并没有自己的前置声明 注意：前置声明只能作为指针或引用，不能定义类的对象，自然也就不能调用对象中的方法。详见：https://www.cnblogs.com/fwycmengsoft/p/4061989.html 条件编译1.if格式 #if 表达式 语句序列① [#else 语句序列②] #endif 功能：当表达式的值为真时，编译语句序列①，否则编译语句序列②。其中，#else和语句序列②可有可无。 2.ifdef格式 #ifdef 标识符 语句序列① [#else 语句序列②] #endif 功能：当标识符已被定义时（用#define定义），编译语句序列①，否则编译语句序列②。其中#else和语句序列②可有可无。 3.ifndef格式 #ifndef 标识符 语句序列① [#else 语句序列②] #endif 功能：该格式功能与ifdef相反。 在头文件中常用条件编译语句实现包含警戒，常见格式如下： //example.h #ifndef EXAMPLEH #def EXAMPLEH ... (头文件具体代码) ... #endif 全新的运算符先介绍 new 和 delete 两个运算符，他们取代了malloc和free函数用法： float *pai=new float(3.14); //开辟一个单精度数的空间，地址赋给指针变量pai，同时给该空间赋值3.14，失败返回NULL int *p=new int[10]; //开辟一个int数组，new数组时不能赋初值 class people *iptr=new people; //new一个类空间 iptr-&gt;height=123; delete []p; //去除int[10]数组的空间 delete pai; //去除一个float变量的空间 引用单变量引用对以下代码： int a=1; const int &amp;temp=a; temp是a的引用，但是无法被赋值从而改变a的值，但是可以对a赋值 对一个函数声明的形参中用const对以下代码： int sum(const int ar[],int n) &#123; int i,total=0; for(i=0;i&lt;n;i++) total+=ar[i]; return total; &#125; 这里const的作用是要求函数在处理数组ar时将其视作常量，不可更改，这样可以保护数组的数据不被修改。一旦发生修改，编译器会产生错误并提示。传参时直接传int型的数组没有问题。如果需要修改数组的内容，则不加const。 类C++的灵魂是面向对象的程序设计，最重要的就是类的掌握 定义对象（类似结构体）1.class 类名 对象名也可以把class省略 直接“类名 对象名”C++中结构体定义变量可以省略strcut 2.声明类的同时定义对象 class XXX&#123; ... &#125;xxx1,xxx2; 也可以不带XXX（不推荐） 类的指针类似结构体，定义指针变量可以 wchar_t（宽字符类型）主要用于存储东亚地区的字符","path":"2021/05/20/随便写一点C-相关内容/","date":"05-20","excerpt":"C++之路道阻且长TAT","tags":[{"name":"思考","slug":"思考","permalink":"https://beepwatch.github.io/tags/%E6%80%9D%E8%80%83/"}],"preview":"/imgs/preview/preview17.jpg"},{"title":"相对路径与绝对路径","text":"在HTML里只要涉及文件的地方(如超级链接、图片等)就会涉及绝对路径与相对路径的概念。 1.绝对路径绝对路径是指文件在硬盘上真正存在的路径。例如“bg.jpg”这个图片是存放在硬盘的“E:\\book\\网页布局代码\\第2章”目录下，那么 “bg.jpg”这个图片的绝对路径就是“E:\\book\\网页布\\代码\\第2章\\bg.jpg”。那么如果要使用绝对路径指定网页的背景图片就应该使用 以下语句： &lt;body backround=”E:\\book\\网页布局\\代码\\第2章\\bg.jpg” &gt; 2.使用绝对路径的缺点事实上，在网页编程时，很少会使用绝对路径，如果使用“E:\\book\\网页布\\代码\\第2章\\bg.jpg”来指定背景图片的位置，在自己的计算机上 浏览可能会一切正常，但是上传到Web服务器上浏览就很有可能不会显示图片了。因为上传到Web服务器上时，可能整个网站并没有放在Web服务器的E盘， 有可能是D盘或H盘。即使放在Web服务器的E盘里，Web服务器的E盘里也不一定会存在“E:\\book\\网页布局\\代码\\第2章”这个目录，因此在浏览网页时是不会显示图片的。 3.相对路径为了避免这种隋况发生，通常在网页里指定文件时，都会选择使用相对路径。所谓相对路径，就是相对于自己的目标文件位置。例如上面的例子，“s1.htm” 文件里引用了“bg.jpg”图片，由于“bg.jpg”图片相对于“s1.htm”来说，是在同一个目录的，那么要在“s1.htm”文件里使用以下代码后，只要这两个文件的相对位置没有变(也就是说还是在同一个目录内)，那么无论上传到Web服务器的哪个位置，在浏览器里都能正确地显示图片。 &lt;body background=”bg.jpg”&gt; 再举一个例子，假设“s1.htm”文件所在目录为“E:\\book\\网页布局\\代码\\第2章”，而“bg.jpg”图片所在目录为“E:\\book\\网页 布局\\代码\\第2章\\img”，那么“bg.jpg”图片相对于“s1.htm”文件来说，是在其所在目录的“img”子目录里，则引用图片的语句应该 为： &lt;body background=”img/bg.jpg”&gt; 注意：相对路径使用“/”字符作为目录的分隔字符，而绝对路径可以使用“\\”或“/”字符作为目录的分隔字符。由于“img”目录是“第2章”目录下的子目录，因此在“img”前不用再加上“/”字符。 在 相对路径里常使用“../”来表示上一级目录。如果有多个上一级目录，可以使用多个“../”。假设 “s1.htm”文件所在目录为“E:\\book\\网页布局\\代码\\第2章”，而“bg.jpg”图片所在目录为“E:\\book\\网页布局\\代码”，那 么“bg.jpg”图片相对于“s1.htm”文件来说，是在其所在目录的上级目录里，则引用图片的语句应该为： &lt;body background=”../bg.jpg”&gt; 再举一个例子，假设“s1.htm”文件所在目录为“E:\\book\\网页布局\\代码\\第2章”，而“bg.jpg”图片所在目录为“E:\\book\\网 页布局\\代码\\img”，那么“bg.jpg”图片相对于“s1.htm”文件来说，是在其所在目录的上级目录里的“img”子目录里，则引用图片的语句 应该为： &lt;body background=”../img/bg.jpg”&gt; 4.相对虚拟目录有关相对路径还有一个比较特殊的表示：“相对虚拟目录”。请看下面的例子： &lt;body background=”/img/bg.jpg”&gt; 在这个例子里，background属性的值为“/img/bg.jpg”，注意在“img”前有一个“/”字符。这个“/”代表的是虚拟目录的根目录. 假设把“E:\\book\\网页布局\\代码”设为虚拟目录，那么“/img/bg.jpg”的真实路径为“E:\\book\\网页布局\\代码\\img \\bg.jpg”；如果把“E:\\book\\网页布局\\代码\\第2章”设为虚拟目录，那么“/img/bg.jpg”的真实路径为“E:\\book\\网页 布局\\代码\\第2章\\img\\bg.jpg” PS：1、”&quot;用于DOS操作系统，”/“用于Unix操作系统；2、Windows操作系统可用”&quot;或”/“；在访问共享文件的客户端需要使用”/“；内部目录路径可使用”&quot;或”/“；3、浏览器地址栏网址访问要使用”/“；4、因在C语言中”&quot;表示转义字符，所以在字符串中表示”&quot;就必须用”\\“；5、相对路径“./“表示当前路径；“../“表示当前路径的上一级路径；“../../“表示当前路径的上上一级路径。————————————————版权声明：本文为CSDN博主「大浪淘沙胡」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_27474555/article/details/107950130转载自：https://blog.csdn.net/mllovehk/article/details/83003677","path":"2021/05/11/相对路径与绝对路径/","date":"05-11","excerpt":"","tags":[{"name":"思考","slug":"思考","permalink":"https://beepwatch.github.io/tags/%E6%80%9D%E8%80%83/"}],"preview":"/imgs/preview/preview15.jpg"},{"title":"若干冷知识","text":"瞎几把记QAQ 1. 在C++中强制类型转换有两种形式 可以是int(1.23)也可以是(int)1.23 而在C语言中只支持后者，前者会报错 2. unsigned(-1)（C++中的表示方法，参见第一条）表示无符号数的最大值 因为-1是以补码形式保存的，而无符号数全部二进制位都表示数值本身 -1的原码为1000 0000 0000 0000 0000 0000 0000 0001 -1的补码为1111 1111 1111 1111 1111 1111 1111 1111 即2^32-1==4294967296 printf(&quot;%u&quot;,-1); cout&lt;&lt;unsigned(-1)&lt;&lt;endl; 3. getchar();实际上是fgetc(stdin);的一个宏定义，因为键盘也是一个文件 4. 字符串数组可以用二维数组实现如char a[10][10]={“apple”,”pear”}; 或者初始化算子char*a[10]={“apple”,”pear”}; (不推荐)","path":"2021/04/05/若干冷知识/","date":"04-05","excerpt":"瞎几把记QAQ","tags":[{"name":"思考","slug":"思考","permalink":"https://beepwatch.github.io/tags/%E6%80%9D%E8%80%83/"}],"preview":"/imgs/preview/preview14.jpg"},{"title":"C语言中的文件操作","text":"先列出几个ASCII码写入的函数，在这些函数中，每个字符占用一个字节，可以用记事本直接打开查看 文件的打开与关闭fp=fopen(filename,mode); filename是一个字符串，这个字符串可以包括文件路径可以采用如下形式 char ch[60]=&quot;c:\\\\users\\\\me\\\\Desktop\\\\newfolder\\\\text.txt&quot; FILE *fp=fopen(ch,&quot;a+&quot;); 注意文件路径不区分大小写，需要使用两个反斜杠，因为反斜杠在c语言中是转义字符PS：直接在C盘根目录写入可能会失败，原因是没有权限 打开一个文件成功返回文件指针 失败返回NULL fclose(fp); 关闭一个文件成功返回0 失败返回EOF(-1) 单个字符的读写int fgetc(FILE *fp); 从读写指针开始读一个字符成功返回字符ASCII码 失败或文件结束返回EOF(-1) int fputc(int ch,FILE *fp); 从读写指针开始写入一个字符成功返回字符ASCII码 失败返回EOF(-1) 字符串读写char *fgets(char *str,int num,FILE *fp); num通常是str字符数组的长度，最多读入num-1个字符，否则强制结束字符串的自然结束符是“换行符”和“文件结束符(EOF)”会读入回车，把回车符放在str的末尾再加\\0文件读写指针也会跳过回车成功返回str数组首地址 失败返回NULL int fputs(char *str,FILE *fp); 从读写指针开始写入一个字符串（单纯的写入字符串，没有其他操作）文件读写指针向前移动strlen(str)个字节成功返回非负值(&gt;=0,由编译器决定) 失败返回EOF(-1) 格式化读写int fscanf(FILE *fp,char *format,arg_list); fscanf(fp,&quot;%s&quot;,str);//fscanf不会读入回车与空格，将一个单纯的字符串读入 int fprintf(FILE *fp,char *format,arg_list); 无论是否以带b的形式fopen一个文件，文件操作函数都可以用（待验证） 以上函数都是以ASCII码形式写入，会占用较多的存储空间，耗时也长接下来介绍数据块读写，相对而言占用空间少，耗时短 fwrite fread ftell fseek ————————–更新————————– fscanf使用时的注意fscanf的格式控制要注意不能出现如%.2f之类的格式控制符，但是%f是可以的如一个文件example.txt中只有12.34这个数字，想把它读入变量float a中使用fscanf(fp,”%f”,&amp;a);即可，用%.2f则会读入失败，返回值为0 与此不同的是，fprintf可以自由控制格式，随意向文件中写入 PS：fscanf读入非字符时，会自动过滤前面的空格，就像scanf(“%d”,&amp;num);一样，不论前面输入多少空格都不影响最后的读入 fgets使用时的注意在对文件的某一行使用fgets时，会把这一行的最后的回车符也读入，并在读入的字符数组中将回车符作为数组的最后一个字符，再在结尾加上’\\0’ 随机读写模式之间有差别r+:以可读可写方式打开一个ASCII文件w+:以可读可写方式打开或新建一个ASCII文件，原有文件内容全部删除a+:同w+，但是不删除原有文件内容 r+可读可写，文件读写指针都在文件开头w+会把文件内容给你扬了，文件读写指针都在文件开头a+可读可写，但是读取从文件开头开始，并且可以用fseek和rewind控制，但是写入永远只能在文件结尾","path":"2021/03/29/C语言中的文件操作/","date":"03-29","excerpt":"","tags":[{"name":"思考","slug":"思考","permalink":"https://beepwatch.github.io/tags/%E6%80%9D%E8%80%83/"}],"preview":"/imgs/preview/preview12.jpg"},{"title":"C中进制数的表达","text":"以0开头为八进制如0101表示十进制数65以0X或0x开头为十六进制如0x101表示十进制数257 简单的验证： #include&lt;stdio.h&gt;int main(){ printf(“%d”,0101); return 0;} 输出结果是65 在printf中%d表示以十进制格式输出%o表示以八进制格式输出注意%D和%O编译器不一定认识，尽量不要使用%x表示以十六进制格式输出（以小写字母）%X表示以十六进制格式输出（以大写字母）输出时不含前缀0和0X 在scanf中%d表示以十进制格式输入%o表示以八进制格式输入%x或者%X表示以十六进制格式输入（输入可以不分大小写） 字符常量可用一个数表示，它可以是十进制，八进制，十六进制如字符A有以下表示： 6501010x41‘A’‘\\101’ // ‘\\ddd’为1~3位八进制数所表示的字符，’\\71’就表示字符’9’‘\\x41’ // ‘\\xdd’为1~2位十六进制数所表示的字符","path":"2021/03/21/C中进制数的表达/","date":"03-21","excerpt":"","tags":[{"name":"思考","slug":"思考","permalink":"https://beepwatch.github.io/tags/%E6%80%9D%E8%80%83/"}],"preview":"/imgs/preview/preview11.jpg"},{"title":"float的精度问题","text":"float并不是连续的，它的精度在十进制中只有小数点后6位，有7位有效数字printf中的%.2f格式控制符实际上是对小数点后两位进行四舍五入运行下面的代码输出结果将是1.36 printf(“%.2f”,1.355); 关于long double不同编译器分配字节数可能不同，8、10、12、16都是存在的","path":"2021/03/15/float的精度问题/","date":"03-15","excerpt":"","tags":[{"name":"思考","slug":"思考","permalink":"https://beepwatch.github.io/tags/%E6%80%9D%E8%80%83/"}],"preview":"/imgs/preview/preview10.jpg"},{"title":"第一次返校","text":"踏上旅途 很遗憾这个假期几个人没有聚在一起，暑假一定会相见的 以后一定要自备吃的，就这饭48块，麻了","path":"2021/03/14/第一次返校/","date":"03-14","excerpt":"踏上旅途 很遗憾这个假期几个人没有聚在一起，暑假一定会相见的","tags":[{"name":"第一次","slug":"第一次","permalink":"https://beepwatch.github.io/tags/%E7%AC%AC%E4%B8%80%E6%AC%A1/"}],"preview":"/imgs/preview/preview8.jpg"},{"title":"一些车万曲","text":"车万曲为何如此好听呜呜呜 车万曲 东方ProjectWiki传送门：https://thwiki.cc/ 屑魔女OP var ap = new APlayer({ element: document.getElementById(\"aplayer-NSvaRhIV\"), narrow: false, autoplay: false, showlrc: false, music: { title: \"リテラチュア\", author: \"上田麗奈\", url: \"http://lc-tprElBPl.cn-n1.lcfile.com/44e4b08dbcc0d052a3ff.mp3/01.%E3%83%AA%E3%83%86%E3%83%A9%E3%83%81%E3%83%A5%E3%82%A2.mp3\", pic: \"http://lc-tprElBPl.cn-n1.lcfile.com/b0c707421e926fc33c7d.jpg/cover.jpg\", lrc: \"\" } }); window.aplayers || (window.aplayers = []); window.aplayers.push(ap); 外链制作使用了LeanCloud：https://console.leancloud.cn/ 学习参考：https://www.jianshu.com/p/26a7fc7cc185https://www.jianshu.com/p/3fb29cc7a00b","path":"2021/03/10/一些车万曲/","date":"03-10","excerpt":"车万曲为何如此好听呜呜呜","tags":[{"name":"东方Project","slug":"东方Project","permalink":"https://beepwatch.github.io/tags/%E4%B8%9C%E6%96%B9Project/"}],"preview":"imgs/preview/preview1.jpg"},{"title":"新人的MAD","text":"为了庆祝某废柴Yuki的誕生日而剪的MAD OvO 嵌入B站视频自适应最佳方案代码：style=”width: 100%; height: 500px; max-width: 100%；align:center; padding:20px 0;” 学习参考：https://cjh0613.com/20200405hexo-bilibili.html","path":"2021/03/10/新人的MAD/","date":"03-10","excerpt":"为了庆祝某废柴Yuki的誕生日而剪的MAD OvO","tags":[{"name":"MAD","slug":"MAD","permalink":"https://beepwatch.github.io/tags/MAD/"}],"preview":"imgs/preview/preview4.jpg"},{"title":"一些实用的网站","text":"老司机看过来OvO 动画BT下载网站漫猫BT：http://www.comicat.org/MioBT：http://miobt.com/简单动漫：https://www.36dm.com/蜜柑计划：https://mikanani.me/ 直接看动画网站ZzzFun：http://www.zzzfun.com/樱花动漫：http://www.imomoe.ai/ 动画音乐资源网站漫音社：http://www.acgjc.com/二次元虫洞：http://www.2cycd.com/forum-43-1.html 插画网站Pixiv：https://www.pixiv.net/ 游戏资源网站维咔ACG：https://www.vikacg.com/?variant=zh-cn夜羊社资源站：https://42yoru.xyz/忧郁的loli：https://www.kkgal.com/终点论坛：https://bbs.zdfx.net/喵窝：https://www.nyanvo.com/ 工具网站MSDN（我告诉你）：https://msdn.itellyou.cn/Lantern的Github下载链接：https://github.com/getlantern/lantern英语作文语法检错（会误报）：https://www.nounplus.net/grammarcheck/果核剥壳：https://www.ghpym.com/","path":"2021/03/10/一些实用的网站/","date":"03-10","excerpt":"老司机看过来OvO","tags":[{"name":"实用","slug":"实用","permalink":"https://beepwatch.github.io/tags/%E5%AE%9E%E7%94%A8/"}],"preview":"imgs/preview/preview7.jpg"},{"title":"欢迎来到嘟嘟噜の怀表的博客Ciallo～","text":"在2021.03.09这一天在众人帮助之下终于建成了这个博客这实在是很具有纪念意义QAQ 这里也会记录一些搭建博客过程中的问题 文章预览代码： &lt;!– more –&gt; Hexo多tags语法：第一种： tags:[a,b,c] 第二种：（注意空格） tags:- abc- def- xxx 自定义文章封面可以在front-matter中添加preview: 文件夹默认从source开始寻找 例如preview: imgs\\preview\\ 修改文章的默认front-matter可以修改根目录中的scaffolds/post.md文件 添加图片的格式参考： ![这里可以写关于图片的描述](/images/philly-magic-gardens.jpg “Philadelphia’s Magic Gardens”) 关于front-matter更多内容参考：https://segmentfault.com/a/1190000020067490http://ijiaober.github.io/2014/08/05/hexo/hexo-04/ markdown的语法参考：http://markdown.p2hp.com/basic-syntax/https://www.appinn.com/markdown/ 1.加粗内容可以在目标内容两侧同时加上两个星号或者两个下划线","path":"2021/03/09/欢迎来到嘟嘟噜の怀表的博客Ciallo～/","date":"03-09","excerpt":"在2021.03.09这一天在众人帮助之下终于建成了这个博客这实在是很具有纪念意义QAQ 这里也会记录一些搭建博客过程中的问题","tags":[{"name":"第一次","slug":"第一次","permalink":"https://beepwatch.github.io/tags/%E7%AC%AC%E4%B8%80%E6%AC%A1/"}],"preview":"imgs/preview/preview5.jpg"}],"categories":[],"tags":[{"name":"思考","slug":"思考","permalink":"https://beepwatch.github.io/tags/%E6%80%9D%E8%80%83/"},{"name":"第一次","slug":"第一次","permalink":"https://beepwatch.github.io/tags/%E7%AC%AC%E4%B8%80%E6%AC%A1/"},{"name":"东方Project","slug":"东方Project","permalink":"https://beepwatch.github.io/tags/%E4%B8%9C%E6%96%B9Project/"},{"name":"MAD","slug":"MAD","permalink":"https://beepwatch.github.io/tags/MAD/"},{"name":"实用","slug":"实用","permalink":"https://beepwatch.github.io/tags/%E5%AE%9E%E7%94%A8/"}]}